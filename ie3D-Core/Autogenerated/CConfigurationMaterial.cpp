// autogenerated: do not add any changes
#include "CConfigurationMaterial.h"
std::string CConfigurationMaterial::getRenderTechniqueName(void) const
{
const auto& iterator = m_attributes.find("/material/render_operation_name");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setRenderTechniqueName(std::string render_operation_name)
{
IConfiguration::setAttribute("/material/render_operation_name", std::make_shared<CConfigurationAttribute>(render_operation_name));
}
#endif
bool CConfigurationMaterial::getDepthTest(void) const
{
const auto& iterator = m_attributes.find("/material/is_depth_test");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setDepthTest(bool is_depth_test)
{
IConfiguration::setAttribute("/material/is_depth_test", std::make_shared<CConfigurationAttribute>(is_depth_test));
}
#endif
bool CConfigurationMaterial::getDepthMask(void) const
{
const auto& iterator = m_attributes.find("/material/is_depth_mask");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setDepthMask(bool is_depth_mask)
{
IConfiguration::setAttribute("/material/is_depth_mask", std::make_shared<CConfigurationAttribute>(is_depth_mask));
}
#endif
bool CConfigurationMaterial::getCulling(void) const
{
const auto& iterator = m_attributes.find("/material/is_cull_face");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setCulling(bool is_cull_face)
{
IConfiguration::setAttribute("/material/is_cull_face", std::make_shared<CConfigurationAttribute>(is_cull_face));
}
#endif
GLenum CConfigurationMaterial::getCullingMode(void) const
{
const auto& iterator = m_attributes.find("/material/cull_face_mode");
assert(iterator != m_attributes.end());
GLenum value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setCullingMode(GLenum cull_face_mode)
{
IConfiguration::setAttribute("/material/cull_face_mode", std::make_shared<CConfigurationAttribute>(cull_face_mode));
}
#endif
bool CConfigurationMaterial::getBlending(void) const
{
const auto& iterator = m_attributes.find("/material/is_blending");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setBlending(bool is_blending)
{
IConfiguration::setAttribute("/material/is_blending", std::make_shared<CConfigurationAttribute>(is_blending));
}
#endif
GLenum CConfigurationMaterial::getBlendingFunctionSource(void) const
{
const auto& iterator = m_attributes.find("/material/blending_function_source");
assert(iterator != m_attributes.end());
GLenum value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setBlendingFunctionSource(GLenum blending_function_source)
{
IConfiguration::setAttribute("/material/blending_function_source", std::make_shared<CConfigurationAttribute>(blending_function_source));
}
#endif
GLenum CConfigurationMaterial::getBlendingFunctionDestination(void) const
{
const auto& iterator = m_attributes.find("/material/blending_function_destination");
assert(iterator != m_attributes.end());
GLenum value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setBlendingFunctionDestination(GLenum blending_function_destination)
{
IConfiguration::setAttribute("/material/blending_function_destination", std::make_shared<CConfigurationAttribute>(blending_function_destination));
}
#endif
bool CConfigurationMaterial::getClipping(void) const
{
const auto& iterator = m_attributes.find("/material/is_cliping");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setClipping(bool is_cliping)
{
IConfiguration::setAttribute("/material/is_cliping", std::make_shared<CConfigurationAttribute>(is_cliping));
}
#endif
f32 CConfigurationMaterial::getClippingX(void) const
{
const auto& iterator = m_attributes.find("/material/clipping_x");
assert(iterator != m_attributes.end());
f32 value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setClippingX(f32 clipping_x)
{
IConfiguration::setAttribute("/material/clipping_x", std::make_shared<CConfigurationAttribute>(clipping_x));
}
#endif
f32 CConfigurationMaterial::getClippingY(void) const
{
const auto& iterator = m_attributes.find("/material/clipping_y");
assert(iterator != m_attributes.end());
f32 value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setClippingY(f32 clipping_y)
{
IConfiguration::setAttribute("/material/clipping_y", std::make_shared<CConfigurationAttribute>(clipping_y));
}
#endif
f32 CConfigurationMaterial::getClippingZ(void) const
{
const auto& iterator = m_attributes.find("/material/clipping_z");
assert(iterator != m_attributes.end());
f32 value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setClippingZ(f32 clipping_z)
{
IConfiguration::setAttribute("/material/clipping_z", std::make_shared<CConfigurationAttribute>(clipping_z));
}
#endif
f32 CConfigurationMaterial::getClippingW(void) const
{
const auto& iterator = m_attributes.find("/material/clipping_w");
assert(iterator != m_attributes.end());
f32 value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setClippingW(f32 clipping_w)
{
IConfiguration::setAttribute("/material/clipping_w", std::make_shared<CConfigurationAttribute>(clipping_w));
}
#endif
bool CConfigurationMaterial::getReflecting(void) const
{
const auto& iterator = m_attributes.find("/material/is_reflecting");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setReflecting(bool is_reflecting)
{
IConfiguration::setAttribute("/material/is_reflecting", std::make_shared<CConfigurationAttribute>(is_reflecting));
}
#endif
bool CConfigurationMaterial::getShadowing(void) const
{
const auto& iterator = m_attributes.find("/material/is_shadowing");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setShadowing(bool is_shadowing)
{
IConfiguration::setAttribute("/material/is_shadowing", std::make_shared<CConfigurationAttribute>(is_shadowing));
}
#endif
bool CConfigurationMaterial::getDebugging(void) const
{
const auto& iterator = m_attributes.find("/material/is_debugging");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setDebugging(bool is_debugging)
{
IConfiguration::setAttribute("/material/is_debugging", std::make_shared<CConfigurationAttribute>(is_debugging));
}
#endif
std::shared_ptr<CConfigurationShader> CConfigurationMaterial::getShaderConfiguration(void) const
{
const auto& iterator = m_configurations.find("/material/shader");
if(iterator == m_configurations.end())
{
return nullptr;
}
assert(iterator != m_configurations.end());
assert(iterator->second.size() != 0);
return std::static_pointer_cast<CConfigurationShader>(iterator->second.at(0));
}
#if defined(__EDITOR__)
void CConfigurationMaterial::setShaderConfiguration(const std::shared_ptr<CConfigurationShader>& shader)
{
IConfiguration::setConfiguration("/material/shader", shader, 0);
}
#endif
std::vector<std::shared_ptr<IConfiguration>> CConfigurationMaterial::getTexturesConfigurations(void) const
{
const auto& iterator = m_configurations.find("/material/textures/texture");
if(iterator == m_configurations.end())
{
return std::vector<std::shared_ptr<IConfiguration>>();
}
assert(iterator != m_configurations.end());
return iterator->second;
}
#if defined(__EDITOR__)
void CConfigurationMaterial::addTexturesConfigurations(const std::shared_ptr<CConfigurationTexture>& texture)
{
IConfiguration::setConfiguration("/material/textures/texture", texture);
}
#endif
#if defined(__EDITOR__)
void CConfigurationMaterial::setTexturesConfigurations(const std::shared_ptr<CConfigurationTexture>& texture, i32 index)
{
IConfiguration::setConfiguration("/material/textures/texture", texture, index);
}
#endif
void CConfigurationMaterial::serialize(const std::string& filename)
{
pugi::xml_document document;
pugi::xml_parse_result result = IConfiguration::openXMLDocument(document, filename);
assert(result.status == pugi::status_ok);
pugi::xpath_node node;
node = document.select_single_node("/material");
std::string render_operation_name = node.node().attribute("render_operation_name").as_string();
IConfiguration::setAttribute("/material/render_operation_name", std::make_shared<CConfigurationAttribute>(render_operation_name));
bool is_depth_test = node.node().attribute("is_depth_test").as_bool();
IConfiguration::setAttribute("/material/is_depth_test", std::make_shared<CConfigurationAttribute>(is_depth_test));
bool is_depth_mask = node.node().attribute("is_depth_mask").as_bool();
IConfiguration::setAttribute("/material/is_depth_mask", std::make_shared<CConfigurationAttribute>(is_depth_mask));
bool is_cull_face = node.node().attribute("is_cull_face").as_bool();
IConfiguration::setAttribute("/material/is_cull_face", std::make_shared<CConfigurationAttribute>(is_cull_face));
std::string cull_face_mode = node.node().attribute("cull_face_mode").as_string();
assert(g_stringToGLenum.find(cull_face_mode) != g_stringToGLenum.end());
GLenum cull_face_modeEnum = g_stringToGLenum.find(cull_face_mode)->second;
IConfiguration::setAttribute("/material/cull_face_mode", std::make_shared<CConfigurationAttribute>(cull_face_modeEnum));
bool is_blending = node.node().attribute("is_blending").as_bool();
IConfiguration::setAttribute("/material/is_blending", std::make_shared<CConfigurationAttribute>(is_blending));
std::string blending_function_source = node.node().attribute("blending_function_source").as_string();
assert(g_stringToGLenum.find(blending_function_source) != g_stringToGLenum.end());
GLenum blending_function_sourceEnum = g_stringToGLenum.find(blending_function_source)->second;
IConfiguration::setAttribute("/material/blending_function_source", std::make_shared<CConfigurationAttribute>(blending_function_sourceEnum));
std::string blending_function_destination = node.node().attribute("blending_function_destination").as_string();
assert(g_stringToGLenum.find(blending_function_destination) != g_stringToGLenum.end());
GLenum blending_function_destinationEnum = g_stringToGLenum.find(blending_function_destination)->second;
IConfiguration::setAttribute("/material/blending_function_destination", std::make_shared<CConfigurationAttribute>(blending_function_destinationEnum));
bool is_cliping = node.node().attribute("is_cliping").as_bool();
IConfiguration::setAttribute("/material/is_cliping", std::make_shared<CConfigurationAttribute>(is_cliping));
f32 clipping_x = node.node().attribute("clipping_x").as_float();
IConfiguration::setAttribute("/material/clipping_x", std::make_shared<CConfigurationAttribute>(clipping_x));
f32 clipping_y = node.node().attribute("clipping_y").as_float();
IConfiguration::setAttribute("/material/clipping_y", std::make_shared<CConfigurationAttribute>(clipping_y));
f32 clipping_z = node.node().attribute("clipping_z").as_float();
IConfiguration::setAttribute("/material/clipping_z", std::make_shared<CConfigurationAttribute>(clipping_z));
f32 clipping_w = node.node().attribute("clipping_w").as_float();
IConfiguration::setAttribute("/material/clipping_w", std::make_shared<CConfigurationAttribute>(clipping_w));
bool is_reflecting = node.node().attribute("is_reflecting").as_bool();
IConfiguration::setAttribute("/material/is_reflecting", std::make_shared<CConfigurationAttribute>(is_reflecting));
bool is_shadowing = node.node().attribute("is_shadowing").as_bool();
IConfiguration::setAttribute("/material/is_shadowing", std::make_shared<CConfigurationAttribute>(is_shadowing));
bool is_debugging = node.node().attribute("is_debugging").as_bool();
IConfiguration::setAttribute("/material/is_debugging", std::make_shared<CConfigurationAttribute>(is_debugging));
std::shared_ptr<CConfigurationShader> shader = std::make_shared<CConfigurationShader>();
shader->serialize(document, "/material");
IConfiguration::setConfiguration("/material/shader", shader);
pugi::xpath_node_set texture_nodes = document.select_nodes("/material/textures/texture");
for (pugi::xpath_node_set::const_iterator iterator = texture_nodes.begin(); iterator != texture_nodes.end(); ++iterator)
{
std::shared_ptr<CConfigurationTexture> texture = std::make_shared<CConfigurationTexture>();
pugi::xpath_node node = (*iterator);
texture->serialize(document, node);
IConfiguration::setConfiguration("/material/textures/texture", texture);
}
}
#if defined(__EDITOR__)
void CConfigurationMaterial::deserialize(const std::string& filename)
{
pugi::xml_document document;
pugi::xml_parse_result result = document.load("");
assert(result.status == pugi::status_ok);
pugi::xml_node node = document.append_child("material");
pugi::xml_node parent_node = node;
pugi::xml_attribute attribute;
attribute = node.append_attribute("render_operation_name");
std::string render_operation_name = CConfigurationMaterial::getRenderTechniqueName();
attribute.set_value(render_operation_name.c_str());
attribute = node.append_attribute("is_depth_test");
bool is_depth_test = CConfigurationMaterial::getDepthTest();
attribute.set_value(is_depth_test);
attribute = node.append_attribute("is_depth_mask");
bool is_depth_mask = CConfigurationMaterial::getDepthMask();
attribute.set_value(is_depth_mask);
attribute = node.append_attribute("is_cull_face");
bool is_cull_face = CConfigurationMaterial::getCulling();
attribute.set_value(is_cull_face);
attribute = node.append_attribute("cull_face_mode");
GLenum cull_face_modeEnum = CConfigurationMaterial::getCullingMode();
assert(g_enumGLToString.find(cull_face_modeEnum) != g_enumGLToString.end());
std::string cull_face_mode = g_enumGLToString.find(cull_face_modeEnum)->second;
attribute.set_value(cull_face_mode.c_str());
attribute = node.append_attribute("is_blending");
bool is_blending = CConfigurationMaterial::getBlending();
attribute.set_value(is_blending);
attribute = node.append_attribute("blending_function_source");
GLenum blending_function_sourceEnum = CConfigurationMaterial::getBlendingFunctionSource();
assert(g_enumGLToString.find(blending_function_sourceEnum) != g_enumGLToString.end());
std::string blending_function_source = g_enumGLToString.find(blending_function_sourceEnum)->second;
attribute.set_value(blending_function_source.c_str());
attribute = node.append_attribute("blending_function_destination");
GLenum blending_function_destinationEnum = CConfigurationMaterial::getBlendingFunctionDestination();
assert(g_enumGLToString.find(blending_function_destinationEnum) != g_enumGLToString.end());
std::string blending_function_destination = g_enumGLToString.find(blending_function_destinationEnum)->second;
attribute.set_value(blending_function_destination.c_str());
attribute = node.append_attribute("is_cliping");
bool is_cliping = CConfigurationMaterial::getClipping();
attribute.set_value(is_cliping);
attribute = node.append_attribute("clipping_x");
f32 clipping_x = CConfigurationMaterial::getClippingX();
attribute.set_value(clipping_x);
attribute = node.append_attribute("clipping_y");
f32 clipping_y = CConfigurationMaterial::getClippingY();
attribute.set_value(clipping_y);
attribute = node.append_attribute("clipping_z");
f32 clipping_z = CConfigurationMaterial::getClippingZ();
attribute.set_value(clipping_z);
attribute = node.append_attribute("clipping_w");
f32 clipping_w = CConfigurationMaterial::getClippingW();
attribute.set_value(clipping_w);
attribute = node.append_attribute("is_reflecting");
bool is_reflecting = CConfigurationMaterial::getReflecting();
attribute.set_value(is_reflecting);
attribute = node.append_attribute("is_shadowing");
bool is_shadowing = CConfigurationMaterial::getShadowing();
attribute.set_value(is_shadowing);
attribute = node.append_attribute("is_debugging");
bool is_debugging = CConfigurationMaterial::getDebugging();
attribute.set_value(is_debugging);
node = parent_node.append_child("shader");
CConfigurationMaterial::getShaderConfiguration()->deserialize(node);
node = parent_node.append_child("textures");
for(const auto& iterator : CConfigurationMaterial::getTexturesConfigurations())
{
std::shared_ptr<CConfigurationTexture> configuration = std::static_pointer_cast<CConfigurationTexture>(iterator);
pugi::xml_node child_node = node.append_child("texture");
configuration->deserialize(child_node);
}
document.save_file(filename.c_str());
}
#endif
