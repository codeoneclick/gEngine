// autogenerated: do not add any changes
#include "CConfigurationTexture.h"
bool CConfigurationTexture::getCubemap(void) const
{
const auto& iterator = m_attributes.find("/texture/is_cubemap");
assert(iterator != m_attributes.end());
bool value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setCubemap(bool is_cubemap)
{
IConfiguration::setAttribute("/texture/is_cubemap", std::make_shared<CConfigurationAttribute>(is_cubemap));
}
#endif
std::string CConfigurationTexture::getTextureFilename(void) const
{
const auto& iterator = m_attributes.find("/texture/filename");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setTextureFilename(std::string filename)
{
IConfiguration::setAttribute("/texture/filename", std::make_shared<CConfigurationAttribute>(filename));
}
#endif
std::string CConfigurationTexture::getTextureFilenamePositiveX(void) const
{
const auto& iterator = m_attributes.find("/texture/filename_x_positive");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setTextureFilenamePositiveX(std::string filename_x_positive)
{
IConfiguration::setAttribute("/texture/filename_x_positive", std::make_shared<CConfigurationAttribute>(filename_x_positive));
}
#endif
std::string CConfigurationTexture::getTextureFilenameNegativeX(void) const
{
const auto& iterator = m_attributes.find("/texture/filename_x_negative");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setTextureFilenameNegativeX(std::string filename_x_negative)
{
IConfiguration::setAttribute("/texture/filename_x_negative", std::make_shared<CConfigurationAttribute>(filename_x_negative));
}
#endif
std::string CConfigurationTexture::getTextureFilenamePositiveY(void) const
{
const auto& iterator = m_attributes.find("/texture/filename_y_positive");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setTextureFilenamePositiveY(std::string filename_y_positive)
{
IConfiguration::setAttribute("/texture/filename_y_positive", std::make_shared<CConfigurationAttribute>(filename_y_positive));
}
#endif
std::string CConfigurationTexture::getTextureFilenameNegativeY(void) const
{
const auto& iterator = m_attributes.find("/texture/filename_y_negative");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setTextureFilenameNegativeY(std::string filename_y_negative)
{
IConfiguration::setAttribute("/texture/filename_y_negative", std::make_shared<CConfigurationAttribute>(filename_y_negative));
}
#endif
std::string CConfigurationTexture::getTextureFilenamePositiveZ(void) const
{
const auto& iterator = m_attributes.find("/texture/filename_z_positive");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setTextureFilenamePositiveZ(std::string filename_z_positive)
{
IConfiguration::setAttribute("/texture/filename_z_positive", std::make_shared<CConfigurationAttribute>(filename_z_positive));
}
#endif
std::string CConfigurationTexture::getTextureFilenameNegativeZ(void) const
{
const auto& iterator = m_attributes.find("/texture/filename_z_negative");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setTextureFilenameNegativeZ(std::string filename_z_negative)
{
IConfiguration::setAttribute("/texture/filename_z_negative", std::make_shared<CConfigurationAttribute>(filename_z_negative));
}
#endif
std::string CConfigurationTexture::getRenderTechniqueTextureName(void) const
{
const auto& iterator = m_attributes.find("/texture/render_operation_name");
assert(iterator != m_attributes.end());
std::string value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setRenderTechniqueTextureName(std::string render_operation_name)
{
IConfiguration::setAttribute("/texture/render_operation_name", std::make_shared<CConfigurationAttribute>(render_operation_name));
}
#endif
ui32 CConfigurationTexture::getSamplerIndex(void) const
{
const auto& iterator = m_attributes.find("/texture/sampler_index");
assert(iterator != m_attributes.end());
ui32 value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setSamplerIndex(ui32 sampler_index)
{
IConfiguration::setAttribute("/texture/sampler_index", std::make_shared<CConfigurationAttribute>(sampler_index));
}
#endif
GLenum CConfigurationTexture::getWrapMode(void) const
{
const auto& iterator = m_attributes.find("/texture/wrap_mode");
assert(iterator != m_attributes.end());
GLenum value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setWrapMode(GLenum wrap_mode)
{
IConfiguration::setAttribute("/texture/wrap_mode", std::make_shared<CConfigurationAttribute>(wrap_mode));
}
#endif
GLenum CConfigurationTexture::getMagFilter(void) const
{
const auto& iterator = m_attributes.find("/texture/mag_filter");
assert(iterator != m_attributes.end());
GLenum value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setMagFilter(GLenum mag_filter)
{
IConfiguration::setAttribute("/texture/mag_filter", std::make_shared<CConfigurationAttribute>(mag_filter));
}
#endif
GLenum CConfigurationTexture::getMinFilter(void) const
{
const auto& iterator = m_attributes.find("/texture/min_filter");
assert(iterator != m_attributes.end());
GLenum value; iterator->second->get(&value);
return value;
}
#if defined(__EDITOR__)
void CConfigurationTexture::setMinFilter(GLenum min_filter)
{
IConfiguration::setAttribute("/texture/min_filter", std::make_shared<CConfigurationAttribute>(min_filter));
}
#endif
void CConfigurationTexture::serialize(pugi::xml_document& document, const std::string& path)
{
pugi::xpath_node node;
node = document.select_single_node((path + "/texture").c_str());
bool is_cubemap = node.node().attribute("is_cubemap").as_bool();
IConfiguration::setAttribute("/texture/is_cubemap", std::make_shared<CConfigurationAttribute>(is_cubemap));
std::string filename = node.node().attribute("filename").as_string();
IConfiguration::setAttribute("/texture/filename", std::make_shared<CConfigurationAttribute>(filename));
std::string filename_x_positive = node.node().attribute("filename_x_positive").as_string();
IConfiguration::setAttribute("/texture/filename_x_positive", std::make_shared<CConfigurationAttribute>(filename_x_positive));
std::string filename_x_negative = node.node().attribute("filename_x_negative").as_string();
IConfiguration::setAttribute("/texture/filename_x_negative", std::make_shared<CConfigurationAttribute>(filename_x_negative));
std::string filename_y_positive = node.node().attribute("filename_y_positive").as_string();
IConfiguration::setAttribute("/texture/filename_y_positive", std::make_shared<CConfigurationAttribute>(filename_y_positive));
std::string filename_y_negative = node.node().attribute("filename_y_negative").as_string();
IConfiguration::setAttribute("/texture/filename_y_negative", std::make_shared<CConfigurationAttribute>(filename_y_negative));
std::string filename_z_positive = node.node().attribute("filename_z_positive").as_string();
IConfiguration::setAttribute("/texture/filename_z_positive", std::make_shared<CConfigurationAttribute>(filename_z_positive));
std::string filename_z_negative = node.node().attribute("filename_z_negative").as_string();
IConfiguration::setAttribute("/texture/filename_z_negative", std::make_shared<CConfigurationAttribute>(filename_z_negative));
std::string render_operation_name = node.node().attribute("render_operation_name").as_string();
IConfiguration::setAttribute("/texture/render_operation_name", std::make_shared<CConfigurationAttribute>(render_operation_name));
ui32 sampler_index = node.node().attribute("sampler_index").as_uint();
IConfiguration::setAttribute("/texture/sampler_index", std::make_shared<CConfigurationAttribute>(sampler_index));
std::string wrap_mode = node.node().attribute("wrap_mode").as_string();
assert(g_stringToGLenum.find(wrap_mode) != g_stringToGLenum.end());
GLenum wrap_modeEnum = g_stringToGLenum.find(wrap_mode)->second;
IConfiguration::setAttribute("/texture/wrap_mode", std::make_shared<CConfigurationAttribute>(wrap_modeEnum));
std::string mag_filter = node.node().attribute("mag_filter").as_string();
assert(g_stringToGLenum.find(mag_filter) != g_stringToGLenum.end());
GLenum mag_filterEnum = g_stringToGLenum.find(mag_filter)->second;
IConfiguration::setAttribute("/texture/mag_filter", std::make_shared<CConfigurationAttribute>(mag_filterEnum));
std::string min_filter = node.node().attribute("min_filter").as_string();
assert(g_stringToGLenum.find(min_filter) != g_stringToGLenum.end());
GLenum min_filterEnum = g_stringToGLenum.find(min_filter)->second;
IConfiguration::setAttribute("/texture/min_filter", std::make_shared<CConfigurationAttribute>(min_filterEnum));
}
#if defined(__EDITOR__)
void CConfigurationTexture::deserialize(pugi::xml_node& node)
{
pugi::xml_attribute attribute;
attribute = node.append_attribute("is_cubemap");
bool is_cubemap = CConfigurationTexture::getCubemap();
attribute.set_value(is_cubemap);
attribute = node.append_attribute("filename");
std::string filename = CConfigurationTexture::getTextureFilename();
attribute.set_value(filename.c_str());
attribute = node.append_attribute("filename_x_positive");
std::string filename_x_positive = CConfigurationTexture::getTextureFilenamePositiveX();
attribute.set_value(filename_x_positive.c_str());
attribute = node.append_attribute("filename_x_negative");
std::string filename_x_negative = CConfigurationTexture::getTextureFilenameNegativeX();
attribute.set_value(filename_x_negative.c_str());
attribute = node.append_attribute("filename_y_positive");
std::string filename_y_positive = CConfigurationTexture::getTextureFilenamePositiveY();
attribute.set_value(filename_y_positive.c_str());
attribute = node.append_attribute("filename_y_negative");
std::string filename_y_negative = CConfigurationTexture::getTextureFilenameNegativeY();
attribute.set_value(filename_y_negative.c_str());
attribute = node.append_attribute("filename_z_positive");
std::string filename_z_positive = CConfigurationTexture::getTextureFilenamePositiveZ();
attribute.set_value(filename_z_positive.c_str());
attribute = node.append_attribute("filename_z_negative");
std::string filename_z_negative = CConfigurationTexture::getTextureFilenameNegativeZ();
attribute.set_value(filename_z_negative.c_str());
attribute = node.append_attribute("render_operation_name");
std::string render_operation_name = CConfigurationTexture::getRenderTechniqueTextureName();
attribute.set_value(render_operation_name.c_str());
attribute = node.append_attribute("sampler_index");
ui32 sampler_index = CConfigurationTexture::getSamplerIndex();
attribute.set_value(sampler_index);
attribute = node.append_attribute("wrap_mode");
GLenum wrap_modeEnum = CConfigurationTexture::getWrapMode();
assert(g_enumGLToString.find(wrap_modeEnum) != g_enumGLToString.end());
std::string wrap_mode = g_enumGLToString.find(wrap_modeEnum)->second;
attribute.set_value(wrap_mode.c_str());
attribute = node.append_attribute("mag_filter");
GLenum mag_filterEnum = CConfigurationTexture::getMagFilter();
assert(g_enumGLToString.find(mag_filterEnum) != g_enumGLToString.end());
std::string mag_filter = g_enumGLToString.find(mag_filterEnum)->second;
attribute.set_value(mag_filter.c_str());
attribute = node.append_attribute("min_filter");
GLenum min_filterEnum = CConfigurationTexture::getMinFilter();
assert(g_enumGLToString.find(min_filterEnum) != g_enumGLToString.end());
std::string min_filter = g_enumGLToString.find(min_filterEnum)->second;
attribute.set_value(min_filter.c_str());
}
#endif
void CConfigurationTexture::serialize(pugi::xml_document& document, pugi::xpath_node& node)
{
bool is_cubemap = node.node().attribute("is_cubemap").as_bool();
IConfiguration::setAttribute("/texture/is_cubemap", std::make_shared<CConfigurationAttribute>(is_cubemap));
std::string filename = node.node().attribute("filename").as_string();
IConfiguration::setAttribute("/texture/filename", std::make_shared<CConfigurationAttribute>(filename));
std::string filename_x_positive = node.node().attribute("filename_x_positive").as_string();
IConfiguration::setAttribute("/texture/filename_x_positive", std::make_shared<CConfigurationAttribute>(filename_x_positive));
std::string filename_x_negative = node.node().attribute("filename_x_negative").as_string();
IConfiguration::setAttribute("/texture/filename_x_negative", std::make_shared<CConfigurationAttribute>(filename_x_negative));
std::string filename_y_positive = node.node().attribute("filename_y_positive").as_string();
IConfiguration::setAttribute("/texture/filename_y_positive", std::make_shared<CConfigurationAttribute>(filename_y_positive));
std::string filename_y_negative = node.node().attribute("filename_y_negative").as_string();
IConfiguration::setAttribute("/texture/filename_y_negative", std::make_shared<CConfigurationAttribute>(filename_y_negative));
std::string filename_z_positive = node.node().attribute("filename_z_positive").as_string();
IConfiguration::setAttribute("/texture/filename_z_positive", std::make_shared<CConfigurationAttribute>(filename_z_positive));
std::string filename_z_negative = node.node().attribute("filename_z_negative").as_string();
IConfiguration::setAttribute("/texture/filename_z_negative", std::make_shared<CConfigurationAttribute>(filename_z_negative));
std::string render_operation_name = node.node().attribute("render_operation_name").as_string();
IConfiguration::setAttribute("/texture/render_operation_name", std::make_shared<CConfigurationAttribute>(render_operation_name));
ui32 sampler_index = node.node().attribute("sampler_index").as_uint();
IConfiguration::setAttribute("/texture/sampler_index", std::make_shared<CConfigurationAttribute>(sampler_index));
std::string wrap_mode = node.node().attribute("wrap_mode").as_string();
assert(g_stringToGLenum.find(wrap_mode) != g_stringToGLenum.end());
GLenum wrap_modeEnum = g_stringToGLenum.find(wrap_mode)->second;
IConfiguration::setAttribute("/texture/wrap_mode", std::make_shared<CConfigurationAttribute>(wrap_modeEnum));
std::string mag_filter = node.node().attribute("mag_filter").as_string();
assert(g_stringToGLenum.find(mag_filter) != g_stringToGLenum.end());
GLenum mag_filterEnum = g_stringToGLenum.find(mag_filter)->second;
IConfiguration::setAttribute("/texture/mag_filter", std::make_shared<CConfigurationAttribute>(mag_filterEnum));
std::string min_filter = node.node().attribute("min_filter").as_string();
assert(g_stringToGLenum.find(min_filter) != g_stringToGLenum.end());
GLenum min_filterEnum = g_stringToGLenum.find(min_filter)->second;
IConfiguration::setAttribute("/texture/min_filter", std::make_shared<CConfigurationAttribute>(min_filterEnum));
}
